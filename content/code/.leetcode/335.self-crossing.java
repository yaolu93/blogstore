/*
 * @lc app=leetcode id=335 lang=java
 *
 * [335] Self Crossing
 *
 * https://leetcode.com/problems/self-crossing/description/
 *
 * algorithms
 * Hard (28.97%)
 * Likes:    225
 * Dislikes: 433
 * Total Accepted:    26.6K
 * Total Submissions: 91.8K
 * Testcase Example:  '[2,1,1,2]'
 *
 * You are given an array of integers distance.
 * 
 * You start at point (0,0) on an X-Y plane and you move distance[0] meters to
 * the north, then distance[1] meters to the west, distance[2] meters to the
 * south, distance[3] meters to the east, and so on. In other words, after each
 * move, your direction changes counter-clockwise.
 * 
 * Return true if your path crosses itself, and false if it does not.
 * 
 * 
 * Example 1:
 * 
 * 
 * Input: distance = [2,1,1,2]
 * Output: true
 * 
 * 
 * Example 2:
 * 
 * 
 * Input: distance = [1,2,3,4]
 * Output: false
 * 
 * 
 * Example 3:
 * 
 * 
 * Input: distance = [1,1,1,1]
 * Output: true
 * 
 * 
 * 
 * Constraints:
 * 
 * 
 * 1 <= distance.length <= 10^5
 * 1 <= distance[i] <= 10^5
 * 
 * 
 */

// @lc code=start
class Solution {
    public boolean isSelfCrossing(int[] distance) {
        System.out.println("!!");
    }
}
// @lc code=end

